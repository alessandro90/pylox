import os

EXPRESSION_CLASS_NAME = "Expr"

EXPRESSIONS = {
    "assign": {"name": "Token", "value": EXPRESSION_CLASS_NAME},
    "binary": {
        "left": EXPRESSION_CLASS_NAME,
        "operator": "Token",
        "right": EXPRESSION_CLASS_NAME,
    },
    "call": {
        "callee": EXPRESSION_CLASS_NAME,
        "paren": "Token",
        "arguments": f"list[{EXPRESSION_CLASS_NAME}]",
    },
    "get": {"obj": EXPRESSION_CLASS_NAME, "name": "Token"},
    "grouping": {"expression": EXPRESSION_CLASS_NAME},
    "literal": {"value": "Any"},
    "logical": {
        "left": EXPRESSION_CLASS_NAME,
        "operator": "Token",
        "right": EXPRESSION_CLASS_NAME,
    },
    "set": {
        "obj": EXPRESSION_CLASS_NAME,
        "name": "Token",
        "value": EXPRESSION_CLASS_NAME,
    },
    "super": {"keyword": "Token", "method": "Token"},
    "this": {"keyword": "Token"},
    "unary": {"operator": "Token", "right": EXPRESSION_CLASS_NAME},
    "variable": {"name": "Token"},
}


NOTE = (
    f"# This file is autogenerated from {os.path.basename(__file__)}\n"
    "# Do not manually change it.\n"
)


IMPORTS = (
    "from __future__ import annotations  # NOTE: No need since python 3.10+\n"
    "from typing import Any, Protocol, TypeVar\n"
    "from scanner import Token\n"
)

GEN_COVAR = "T_co"

T_COV_VAR = f'{GEN_COVAR} = TypeVar("{GEN_COVAR}", covariant=True)'


def indent(n=1) -> str:
    return "    " * n


def define_expr_protocol() -> str:
    text = f"class {EXPRESSION_CLASS_NAME}(Protocol[{GEN_COVAR}]):\n"
    text += (
        f"{indent()}def accept(visitor: Visitor[{GEN_COVAR}])"
        + f" -> {GEN_COVAR}:\n"
        + f"{indent(2)}..."
    )
    text += "\n"
    return text


def add_visitor_method(return_type: str, method: str) -> str:
    capitelized = method.capitalize()
    return (
        f"{indent()}@staticmethod\n"
        f"{indent()}def {'visit' + capitelized + EXPRESSION_CLASS_NAME}"
        f"(expr: {capitelized}) -> {return_type}:\n"
        f"{indent(2)}...\n"
    )


def define_visitor(return_type: str, methods: list[str]) -> str:
    text = f"class Visitor(Protocol[{return_type}]):\n"
    for m in methods:
        text += add_visitor_method(return_type, m)
        text += "\n"
    return text


def list_fields(fields: dict[str, str]) -> str:
    return ", ".join(
        [f"{name}: {field_type}" for name, field_type in fields.items()]
    )


def define_expression_class(class_name: str, fields: dict[str, str]) -> str:
    text = f"class {class_name.capitalize()}:\n"
    fields_list = list_fields(fields)
    init_paramaters = (
        "self" if len(fields_list) == 0 else f"self, {list_fields(fields)}"
    )
    text += f"{indent()}def __init__({init_paramaters}):\n"
    for name in fields.keys():
        text += f"{indent(2)}self.{name} = {name}\n"
    if len(fields.keys()) == 0:
        text += f"{indent(2)}pass\n"
    text += "\n"
    text += (
        f"{indent()}def accept(self, visitor: Visitor[{GEN_COVAR}])"
        f" -> {GEN_COVAR}:\n"
        f"{indent(2)}return visitor.visit"
        f"{class_name.capitalize() + EXPRESSION_CLASS_NAME}(self)\n"
    )
    return text


def generate() -> str:
    text = NOTE
    text += "\n"
    text += IMPORTS + "\n\n"
    text += T_COV_VAR + "\n\n\n"
    text += define_visitor(GEN_COVAR, EXPRESSIONS.keys())
    text += "\n"
    text += define_expr_protocol()
    text += "\n\n"
    for class_name, fields in EXPRESSIONS.items():
        text += define_expression_class(class_name, fields)
        text += "\n\n"
    return text[:-1]  # Remove last newline


def write_file(fname: str):
    with open(fname, "w") as f:
        f.write(generate())


if __name__ == "__main__":
    write_file("../pylox/expr.py")
