# This file is autogenerated from expr_generator.py
# Do not manually change it.

from __future__ import annotations  # NOTE: No need since python 3.10+
from typing import Any, Protocol, TypeVar
from token import Token


T_co = TypeVar("T_co", covariant=True)


class Visitor(Protocol[T_co]):
    @staticmethod
    def visitAssignExpr(expr: Assign) -> T_co:
        ...

    @staticmethod
    def visitBinaryExpr(expr: Binary) -> T_co:
        ...

    @staticmethod
    def visitCallExpr(expr: Call) -> T_co:
        ...

    @staticmethod
    def visitGetExpr(expr: Get) -> T_co:
        ...

    @staticmethod
    def visitGroupingExpr(expr: Grouping) -> T_co:
        ...

    @staticmethod
    def visitLiteralExpr(expr: Literal) -> T_co:
        ...

    @staticmethod
    def visitLogicalExpr(expr: Logical) -> T_co:
        ...

    @staticmethod
    def visitSetExpr(expr: Set) -> T_co:
        ...

    @staticmethod
    def visitSuperExpr(expr: Super) -> T_co:
        ...

    @staticmethod
    def visitThisExpr(expr: This) -> T_co:
        ...

    @staticmethod
    def visitUnaryExpr(expr: Unary) -> T_co:
        ...

    @staticmethod
    def visitVariableExpr(expr: Variable) -> T_co:
        ...


class Expr(Protocol[T_co]):
    def accept(visitor: Visitor[T_co]) -> T_co:
        ...


class Assign:
    def __init__(self, name: Token, value: Expr):
        self.name = name
        self.value = value

    def accept(self, visitor: Visitor[T_co]) -> T_co:
        return visitor.visitAssignExpr(self)


class Binary:
    def __init__(self, left: Expr, operator: Token, right: Expr):
        self.left = left
        self.operator = operator
        self.right = right

    def accept(self, visitor: Visitor[T_co]) -> T_co:
        return visitor.visitBinaryExpr(self)


class Call:
    def __init__(self, callee: Expr, paren: Token, arguments: list[Expr]):
        self.callee = callee
        self.paren = paren
        self.arguments = arguments

    def accept(self, visitor: Visitor[T_co]) -> T_co:
        return visitor.visitCallExpr(self)


class Get:
    def __init__(self, obj: Expr, name: Token):
        self.obj = obj
        self.name = name

    def accept(self, visitor: Visitor[T_co]) -> T_co:
        return visitor.visitGetExpr(self)


class Grouping:
    def __init__(self, expression: Expr):
        self.expression = expression

    def accept(self, visitor: Visitor[T_co]) -> T_co:
        return visitor.visitGroupingExpr(self)


class Literal:
    def __init__(self, value: Any):
        self.value = value

    def accept(self, visitor: Visitor[T_co]) -> T_co:
        return visitor.visitLiteralExpr(self)


class Logical:
    def __init__(self, left: Expr, operator: Token, right: Expr):
        self.left = left
        self.operator = operator
        self.right = right

    def accept(self, visitor: Visitor[T_co]) -> T_co:
        return visitor.visitLogicalExpr(self)


class Set:
    def __init__(self, obj: Expr, name: Token, value: Expr):
        self.obj = obj
        self.name = name
        self.value = value

    def accept(self, visitor: Visitor[T_co]) -> T_co:
        return visitor.visitSetExpr(self)


class Super:
    def __init__(self, keyword: Token, method: Token):
        self.keyword = keyword
        self.method = method

    def accept(self, visitor: Visitor[T_co]) -> T_co:
        return visitor.visitSuperExpr(self)


class This:
    def __init__(self, keyword: Token):
        self.keyword = keyword

    def accept(self, visitor: Visitor[T_co]) -> T_co:
        return visitor.visitThisExpr(self)


class Unary:
    def __init__(self, operator: Token, right: Expr):
        self.operator = operator
        self.right = right

    def accept(self, visitor: Visitor[T_co]) -> T_co:
        return visitor.visitUnaryExpr(self)


class Variable:
    def __init__(self, name: Token):
        self.name = name

    def accept(self, visitor: Visitor[T_co]) -> T_co:
        return visitor.visitVariableExpr(self)

